**Использование Drag and Drop API**
API перетаскивания HTML5 DnD API позволяет сделать практически любой элемент на нашей странице перетаскиваемым. В большинстве браузеров выделенный текст, изображения и ссылки по умолчанию перетаскиваются.
Например, если мы начнём перетаскивать логотип Google в поиске Google, то увидим полупрозрачное изображение. Затем это изображение перетаскивается в адресную строку, на элемент <input type="file" /> или даже на рабочий стол. Чтобы сделать другие типы контента
перетаскиваемыми, нам понадобятся API-интерфейсы HTML5 DnD.
Для превращения элемента в перетаскиваемый ему устанавливают атрибут draggable=true.
Практически всё может быть со включённым перетаскиванием: изображения, файлы, ссылки и любая разметка на странице.
В нашем примере мы создадим интерфейс для перестановки некоторых столбцов, размещённых посредством CSS Grid. Базовая разметка для столбцов выглядит так: для каждого столбца установлен draggable-атрибут true.
<div class="container">
    <div draggable="true" class="box">A</div>
    <div draggable="true" class="box">B</div>
    <div draggable="true" class="box">C</div>
</div>
Это CSS для элементов контейнера и боксов. Обратите внимание, что единственное CSS-правило, связанное с функциональностью DnD, это свойство cursor: move. Остальное просто управляет компоновкой и стилями контейнера и боксов.

.container {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 10px;
}
.box {
    border: 3px solid #666;
    background-color: #ddd;
    border-radius: .5em;
    padding: 10px;
    cursor: move;
}
На этом этапе мы можем перетаскивать элементы, но больше ничего не происходит. Чтобы добавить функциональность DnD, нам надо использовать JavaScript API.
**Прослушивание событий перетаскивания**
Есть ряд событий, к которым можно привязать мониторинг всего процесса перетаскивания.
Когда срабатывают эти события:
1. dragstart — когда пользователь начал перетаскивать элемент.
2. drag — каждые несколько сотен миллисекунд, пока длится перетаскивание элемента
или выделение текста.
3. dragenter — когда перетаскиваемый элемент попадает в допустимую цель сброса.
4. dragleave — когда перетаскиваемый элемент покидает допустимую цель сброса.
5. dragover — когда элемент перетаскивается над допустимой целью сброса каждые
несколько сотен миллисекунд.
6. drop — когда элемент сбрасывается в допустимую зону сброса.
7. dragend — в момент завершения перетаскивания, например, при отпускании кнопки мыши или при нажатии Escape.

Чтобы корректно обрабатывать DnD-процесс, нам потребуется:
● исходный элемент (source element) — откуда начинается перетаскивание;
● объект с данными (data payload) — структура, которую мы перетаскиваем;
● целевой элемент (target) — область, в которой мы «ловим» отпускаемый объект.
Исходный элемент может быть изображением, списком, ссылкой, файловым объектом, блоком HTML и т. д. Целевой элемент — зона перетаскивания (drop zone) или набор таких зон для приёма данных, которые пользователь пытается «бросить». Не все элементы могут быть целями: например, изображение не может.
**Обработка начала и завершения перетаскивания**
После того как мы указали для нашего контента атрибуты draggable="true", надо подписаться на событие dragstart, чтобы запустить последовательность DnD для каждого столбца.
Этот код установит прозрачность столбца на 40%, когда пользователь начнёт его перетаскивать, а затем вернёт её на 100% по окончании события перетаскивания:

const items = document.querySelectorAll('.container .box')
const handleDragStart = ({target}) => {
    target.style.opacity = '0.4'
}
const handleDragEnd = ({target}) => {
    target.style.opacity = '1'
}
items.forEach((item) => {
    item.addEventListener('dragstart', handleDragStart)
    item.addEventListener('dragend', handleDragEnd)
})
Чтобы помочь пользователю понять, как взаимодействовать с интерфейсом, используют дополнительные стили, которые мы установим в обработчиках событий dragenter, dragover и dragleave. В примере ниже столбцы не только перетаскиваются, но и служат целями для
перетаскивания. Мы можем помочь пользователю понять это, сделав границу пунктирной, когда он удерживает перетаскиваемый элемент над столбцом. Например, добавим в наш CSS класс over для представления элементов, которые считаются целями перетаскивания:
.box.over {
    border: 3px dotted #666;
}
Затем в нашем JavaScript настроим обработчики событий:
● для добавления класса over, когда столбец перетаскивается над областью, занимаемой
элементом;
● для удаления класса при покидании области.
В обработчике dragend мы также убираем классы в конце перетаскивания:
const items = document.querySelectorAll('.container .box')
const handleDragStart = ({target}) => {
    target.style.opacity = '0.4'
}
const handleDragEnd = ({target}) => {
    target.style.opacity = '1'
    items.forEach((item) => {
    item.classList.remove('over')
})
}
    const handleDragOver = (event) => {
    if (event.cancelable) {
    event.preventDefault()
}
return false
}
const handleDragEnter = ({target}) => {
    target.classList.add('over')
}
const handleDragLeave = ({target}) => {
    target.classList.remove('over')
}
items.forEach((item) => {
    item.addEventListener('dragstart', handleDragStart)
    item.addEventListener('dragover', handleDragOver)
    item.addEventListener('dragenter', handleDragEnter)
    item.addEventListener('dragleave', handleDragLeave)
    item.addEventListener('dragend', handleDragEnd)
})
**В коде стоит обратить внимание на несколько моментов:*
1. При перетаскивании, например, ссылки нам надо предотвратить поведение браузера по
умолчанию, которое заключается в переходе по этой ссылке. Для этого вызовем
event.preventDefault() в обработчике dragover.
2. Обработчик события dragenter используется вместо dragover для переключения
класса over. Если использовать dragover, CSS-класс будет переключаться много раз,
поскольку событие dragover продолжает срабатывать при перемещении курсора внутри
области столбца. А если по какой-то причине потребуется использовать именно
событие dragover, стоит подумать об ограничении количества срабатываний
посредством паттерна throttling или об отключении слушателя события после первого
срабатывания.
**Обработка завершения перетаскивания**
Чтобы обработать момент, когда пользователь отпускает перетаскиваемый объект над целевым
элементом, надо подписаться на событие drop. В обработчике события drop нам потребуется
предотвратить поведение браузера по умолчанию, которое обычно представляет собой
перенаправление.
Предотвратим это поведение, вызвав event.stopPropagation().
…
const handleDrop = (event) => {
    event.stopPropagation()
    return false
}
items.forEach((item) => {
    item.addEventListener('dragstart', handleDragStart)
    item.addEventListener('dragover', handleDragOver)
    item.addEventListener('dragenter', handleDragEnter)
    item.addEventListener('dragleave', handleDragLeave)
    item.addEventListener('dragend', handleDragEnd)
    item.addEventListener('drop', handleDrop)
})
Если запустить код на этом этапе, элемент не займёт новое место. Для этого нам надо использовать объект DataTransfer.
Именно здесь, в dataTransfer, происходит вся магия DnD. Он содержит фрагмент данных, отправленный при перетаскивании. Объект dataTransfer устанавливается в событии dragstart и читается (обрабатывается) в других событиях перетаскивания. Вызов e.dataTransfer.setData(mimeType, dataPayload) позволяет установить MIME-тип объекта и добавить необходимые данные.
В этом примере мы позволим пользователям изменять порядок столбцов. Для этого сначала сохраним HTML-код исходного элемента при старте перетаскивания:
const handleDragStart = ({target}) => {
    target.style.opacity = '0.4'
    e.dataTransfer.effectAllowed = 'move'
    e.dataTransfer.setData('text/html', target.innerHTML)
}
В обработчике drop, где мы обрабатываем отпускание столбца, заменим HTML-код целевого
столбца на код исходного столбца, перетаскиваемый пользователем. Но перед этим проверим,
не происходит ли отпускание на тот же столбец, из которого оно началось.
const handleDrop = (event) => {
    event.stopPropagation()
    const sourceElementHtml = e.dataTransfer.getData('text/html')
    if (event.target.innerHtml === sourceElementHtml) {
        return
    }
    event.target.innerHtml = sourceElementHtml
    return false
}
**Дополнительные свойства объекта перетаскивания**
Объект dataTransfer предоставляет свойства для обеспечения визуальной обратной связи с пользователем в процессе перетаскивания. Эти свойства также используются для управления тем, как каждая цель перетаскивания реагирует на определённый тип данных.
Свойство dataTransfer.effectAllowed устанавливает, какой «тип перетаскивания» пользователь может выполнять с элементом. Он используется в модели обработки перетаскивания и падения для инициализации dropEffect во время событий dragenter и dragover. Свойству могут быть присвоены значения none, copy, copyLink, copyMove, link, linkMove, move, all и uninitialized.
Свойство dataTransfer.dropEffect контролирует данные о том, что пользователь видит во время событий dragenter и dragover. Когда пользователь наводит курсор на целевой элемент, курсор браузера указывает, какой тип операции будет выполняться: копирование, перемещение
или ещё что-то. «Эффект» принимает одно из следующих значений: none, copy, link, move. Метод dataTransfer.setDragImage(imgElement, x, y) применяют для настройки обратной связи браузера по умолчанию в виде полупрозрачного изображения. Мы можем дополнительно установить значок перетаскивания.