/// Сборщик мусора

//Сборка мусора
// При выполнении скрипта движком JS расходуется большое количество памяти.
// Вызываются функции, выполняются циклы, пересобираются объекты, на все эти
// операции интерпретатор должен выделять целые области памяти для хранения
// данных.
// А что происходит, когда какая - то переменная становится не нужна ? Функция
// выполнила свою работу, объявленные переменные внутри замыкания более
// недоступны ни для одной операции и хранить их в памяти не имеет никакого
// смысла.И если движок JS не освободит память, она в скором времени может
// закончиться, и это приведёт к краху нашей программы.
// Главный принцип управлением памятью в JS — это её достижимость.Есть
// множество достижимых значений по умолчанию.Эти значения называются
// корневыми.Они не могут быть удалены.Среди них:
// ● Глобальные переменные
// ● Текущая функция, которая находится на стадии выполнения
// ● Другие функции в текущей цепочке вызовов, их параметры и локальные
// переменные
// 3
// Далее вычисляются иные достижимые значения.Вычисляются они по ссылкам от
// корневых, потом по ссылкам от достижимых и так далее.В итоге, список
// достижимых значений напоминает ветвистое дерево, в котором от корневых
// значений по ссылкам можно пройти к любому нужному нам значению.
// В JavaScript, как и в любом другом языке программирования, есть фоновый
// процесс, который управляет удалением ненужных объектов в памяти.Он
// называется сборщиком мусора(garbage collector).Он отслеживает все объекты,
//     недоступные по ссылкам и удаляет их.
// На предыдущих уроках мы изучали, что объекты у нас записываются в переменные
// по ссылке.
//     Например, если в объекте:
let obj = {
    animal: 'dog'
}

let obj2 = obj;

//Переменную obj перезаписать другим значением:
obj = null;

console.log(obj);
console.log(obj2);

// Ссылок на наш объект более не останется, и он станет недостижим.В итоге, он
// падёт жертвой сборщика мусора, который освободит занимаемую им память.
// Если мы создадим несколько ссылок на объект, записав их в разные переменные, то
// объект удалится только при удалении всех ссылок на объект.
// Может возникнуть такая ситуация, когда несколько объектов имеют ссылки друг на
// друга, но ссылки на корневые объекты удалены.Тогда все эти объекты тоже
// удаляются.
// Алгоритмы работы сборщика мусора
// Алгоритм работы сборщика мусора работает по принципу пометок.По этому
// алгоритму сначала помечаются корневые объекты, далее алгоритм идёт по ссылкам
// из них, далее — по ссылкам от этих ссылок.
// Какой из ранее изученных методов работы он нам напоминает ?

// Конечно же, это рекурсия.Чтобы перебрать все объекты и не забыть ничего, нужно
// запомнить всё, что ты проходил и перейти по всем ссылкам, а далее — по ссылкам
// ссылок до самого конца.
// В языке С есть специальный тип данных — ссылки, на основе которого можно
// строить подобные структуры данных и рассматриваются способы их обхода,
//     которые напоминают работу нашего сборщика мусора.Там подобные структуры
// данных называются деревьями.Действительно, такая структура напоминает
// деревья, корневые объекты — ствол у основания корня.И пока данные достижимы,
//     они «растут» на нашем дереве.

//В итоге, у нас останутся какие-то объекты, которые этот алгоритм не пометил, так
// как к ним нет доступа по ссылкам от корней.Они будут удалены.
//     Естественно, такая работа при больших объёмах данных может существенно влиять
// на производительность выполнения нашей программы.Поэтому есть некоторые
// оптимизации работы сборщика мусора:
// Работа сборщика мусора по возможности производится во время простоев работы
// скрипта.5
// Когда объектов много, сборщик мусора старается их разделять на части.Как в
// аналогии с деревом, сборщик разделяет крупные ветви дерева и проходит их в
// разное время.В итоге, у нас вместо одного большого обхода получается множество
// маленьких обходов.И вместо одной большой потери производительности
// множество маленьких.
// Объекты разделяются по поколениям — на новые и на старые.Зачастую объекты
// живут недолго — функция вызвалась, создала объекты, обработала их, вернула
// какое - то значение и завершилась.Поэтому есть смысл проверять чаще только
// новые объекты.Старые проверяются реже.
// Есть и иные оптимизации работы движков, которые нет смысла рассматривать в
// нашем курсе.Более того, движки совершенствуются, на смену одним оптимизациям
// приходят другие и за всем не уследить.

